import * as anchor from "@coral-xyz/anchor";
import { AssetType, PROGRAM_ID, validatePublicKey, validateTimestamp, validateAmount, findTimeLockPDA } from "./types";
/**
 * Simplified Time-Locked Wallet Client (API-only demonstration)
 *
 * Note: This is a simplified version that shows the API structure.
 * In a real implementation, you would:
 * 1. Import the actual IDL generated by Anchor
 * 2. Properly initialize the Anchor program
 * 3. Implement the actual instruction builders
 */
export class TimeLockClient {
    constructor(connection, wallet, programId) {
        this.connection = connection;
        this.wallet = wallet;
        this.programId = programId || PROGRAM_ID;
    }
    // ========================================================================
    // SOL OPERATIONS
    // ========================================================================
    /**
     * Create a new SOL time-locked wallet
     */
    async createSolTimeLock(params) {
        validateTimestamp(params.unlockTimestamp);
        validatePublicKey(params.owner);
        const [timeLockAccount] = await findTimeLockPDA(params.owner, params.unlockTimestamp, this.programId);
        // In real implementation: build and send transaction
        const mockSignature = "mock_signature_" + Date.now();
        return {
            timeLockAccount,
            signature: mockSignature,
            assetType: AssetType.Sol
        };
    }
    /**
     * Deposit SOL to an existing time-locked wallet
     */
    async depositSol(params) {
        validateAmount(params.amount);
        validatePublicKey(params.timeLockAccount);
        // In real implementation: build and send deposit transaction
        return "mock_deposit_signature_" + Date.now();
    }
    /**
     * Withdraw SOL from a time-locked wallet (only if unlocked)
     */
    async withdrawSol(params) {
        validatePublicKey(params.timeLockAccount);
        validatePublicKey(params.owner);
        // In real implementation: check if unlocked and withdraw
        return "mock_withdraw_signature_" + Date.now();
    }
    // ========================================================================
    // TOKEN OPERATIONS
    // ========================================================================
    /**
     * Create a new Token time-locked wallet
     */
    async createTokenTimeLock(params, depositParams) {
        validateTimestamp(params.unlockTimestamp);
        validatePublicKey(params.owner);
        const [timeLockAccount] = await findTimeLockPDA(params.owner, params.unlockTimestamp, this.programId);
        // In real implementation: build and send transaction
        const mockSignature = "mock_token_signature_" + Date.now();
        return {
            timeLockAccount,
            signature: mockSignature,
            assetType: AssetType.Token
        };
    }
    /**
     * Deposit tokens to an existing time-locked wallet
     */
    async depositToken(params) {
        validateAmount(params.amount);
        validatePublicKey(params.timeLockAccount);
        validatePublicKey(params.tokenFromAta);
        validatePublicKey(params.tokenVault);
        // In real implementation: build and send token deposit transaction
        return "mock_token_deposit_signature_" + Date.now();
    }
    /**
     * Withdraw tokens from a time-locked wallet (only if unlocked)
     */
    async withdrawToken(params) {
        validatePublicKey(params.timeLockAccount);
        validatePublicKey(params.owner);
        validatePublicKey(params.tokenFromVault);
        validatePublicKey(params.tokenToAta);
        // In real implementation: check if unlocked and withdraw tokens
        return "mock_token_withdraw_signature_" + Date.now();
    }
    // ========================================================================
    // QUERY OPERATIONS
    // ========================================================================
    /**
     * Get time-locked wallet account data
     */
    async getTimeLockData(timeLockAccount) {
        validatePublicKey(timeLockAccount);
        // In real implementation: fetch account data from blockchain
        return {
            owner: this.wallet.publicKey,
            unlockTimestamp: new anchor.BN(Date.now() / 1000 + 3600), // 1 hour from now
            assetType: { sol: {} },
            amount: new anchor.BN(1000000000), // 1 SOL in lamports
            isInitialized: true
        };
    }
    /**
     * Check if a time-locked wallet can be withdrawn
     */
    async canWithdraw(timeLockAccount) {
        try {
            const data = await this.getTimeLockData(timeLockAccount);
            const currentTime = Date.now() / 1000;
            return currentTime >= data.unlockTimestamp.toNumber();
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Get remaining lock time in seconds
     */
    async getRemainingLockTime(timeLockAccount) {
        try {
            const data = await this.getTimeLockData(timeLockAccount);
            const currentTime = Date.now() / 1000;
            const unlockTime = data.unlockTimestamp.toNumber();
            return Math.max(0, unlockTime - currentTime);
        }
        catch (error) {
            return 0;
        }
    }
    // ========================================================================
    // UTILITY METHODS
    // ========================================================================
    /**
     * Find the PDA for a time-locked wallet
     */
    async findTimeLockPDA(owner, unlockTimestamp) {
        return findTimeLockPDA(owner, unlockTimestamp, this.programId);
    }
    // ========================================================================
    // STATIC UTILITY METHODS
    // ========================================================================
    /**
     * Validate a public key
     */
    static validatePublicKey(key) {
        validatePublicKey(key);
    }
    /**
     * Validate a timestamp
     */
    static validateTimestamp(timestamp) {
        validateTimestamp(timestamp);
    }
    /**
     * Validate an amount
     */
    static validateAmount(amount) {
        validateAmount(amount);
    }
    /**
     * Create time lock PDA
     */
    static async findTimeLockPDA(owner, unlockTimestamp, programId) {
        return findTimeLockPDA(owner, unlockTimestamp, programId || PROGRAM_ID);
    }
    // ========================================================================
    // GETTERS
    // ========================================================================
    get connectionInstance() {
        return this.connection;
    }
    get walletInstance() {
        return this.wallet;
    }
    get programIdInstance() {
        return this.programId;
    }
}
